
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>repository: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gogazub/myapp/internal/repository/cache-repository.go (70.7%)</option>
				
				<option value="file1">github.com/gogazub/myapp/internal/repository/db-repository.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package repository

import (
        "container/list"
        "context"
        "fmt"
        "log"
        "sync"

        "github.com/gogazub/myapp/internal/model"
)

const maxCacheSize = 1000

type ICacheRepository interface {
        LoadFromDB(psqlRepo IDBRepository)
        Save(ctx context.Context, order *model.Order) error
        GetByID(ctx context.Context, id string) (*model.Order, error)
        GetAll(ctx context.Context) ([]*model.Order, error)
}

type cacheEntry struct {
        elem  *list.Element
        order *model.Order
}

type CacheRepository struct {
        mu    sync.RWMutex
        cache map[string]*cacheEntry

        list *list.List
}

// Кэш репозиторий при создании заполняется данными из БД
func NewCacheRepository() *CacheRepository <span class="cov8" title="1">{
        cache := make(map[string]*cacheEntry)
        return &amp;CacheRepository{
                cache: cache,
                list:  list.New(),
        }
}</span>

// Заполнить мапу значениями из БД
func (repo *CacheRepository) LoadFromDB(psqlRepo IDBRepository) <span class="cov0" title="0">{
        orders, err := psqlRepo.GetAll(context.Background())

        if err != nil </span><span class="cov0" title="0">{
                // Можно добавить флаг на пропуск логирования ctx.Err.
                // То есть пропускать ошибки, по типу таймаута
                log.Println("Error loading orders from DB:", err)
        }</span> else<span class="cov0" title="0"> {
                for _, order := range orders </span><span class="cov0" title="0">{

                        repo.Save(context.Background(), order)
                        if repo.Size() &gt;= maxCacheSize </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
}

// Сохранить OrderModel в кэше по OrderUID
func (r *CacheRepository) Save(ctx context.Context, order *model.Order) error <span class="cov8" title="1">{
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        if ent, ok := r.cache[order.OrderUID]; ok </span><span class="cov8" title="1">{
                // обновляем значение и освежаем позицию
                ent.order = order
                r.list.MoveToBack(ent.elem)
        }</span> else<span class="cov8" title="1"> {
                // новый
                e := r.list.PushBack(order.OrderUID)
                r.cache[order.OrderUID] = &amp;cacheEntry{elem: e, order: order}

        }</span>
        <span class="cov8" title="1">for r.list.Len() &gt; maxCacheSize </span><span class="cov8" title="1">{
                front := r.list.Front()
                if front == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">key := front.Value.(string)
                r.list.Remove(front)
                delete(r.cache, key)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Получить данные о заказе из кэша по uid заказа. Также освежаем элемент в LRU
func (r *CacheRepository) GetByID(ctx context.Context, id string) (*model.Order, error) <span class="cov8" title="1">{
        if err := ctx.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        ent, exists := r.cache[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("order not found")
        }</span>

        <span class="cov8" title="1">r.list.MoveToBack(ent.elem)
        return ent.order, nil</span>
}

func (r *CacheRepository) GetAll(ctx context.Context) ([]*model.Order, error) <span class="cov8" title="1">{
        // Быстрый отказ, если контекст уже отменен, чтобы не лочить mutex лишний раз
        if err := ctx.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r.mu.RLock()
        defer r.mu.RUnlock()

        // Предвыделим память, чтобы избежать лишних аллокаций
        orders := make([]*model.Order, 0, len(r.cache))

        i := 0
        for _, order := range r.cache </span><span class="cov8" title="1">{
                if i%1000 == 0 </span><span class="cov8" title="1">{ // Вместо select с  &lt;-ctx.Done будем редко проверять контекст
                        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">orders = append(orders, order.order)
                i++</span>
        }
        <span class="cov8" title="1">return orders, nil</span>
}

func (r *CacheRepository) Size() int <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.list.Len()
}</span>

// Удаляет n самых старых элементов (с головы списка).
func (r *CacheRepository) evictOldest(n int) <span class="cov0" title="0">{
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                front := r.list.Front()
                if front == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">key := front.Value.(string)
                r.list.Remove(front)
                delete(r.cache, key)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/gogazub/myapp/internal/model"
)

type IDBRepository interface {
        Save(ctx context.Context, order *model.Order) error
        GetByID(ctx context.Context, id string) (*model.Order, error)
        GetAll(ctx context.Context) ([]*model.Order, error)
}

type DBRepository struct {
        db *sql.DB
}

func NewOrderRepository(db *sql.DB) *DBRepository <span class="cov0" title="0">{
        return &amp;DBRepository{db: db}
}</span>

// Save сохраняет заказ вместе с зависимыми сущностями
func (r *DBRepository) Save(ctx context.Context, order *model.Order) error <span class="cov0" title="0">{
        // Прокидываем контекст
        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        if err := r.saveOrder(tx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := r.saveDelivery(tx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := r.savePayment(tx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := r.saveItems(tx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

// GetByID возвращает заказ по ID
func (r *DBRepository) GetByID(ctx context.Context, id string) (*model.Order, error) <span class="cov0" title="0">{
        var order model.Order

        if err := r.loadOrder(ctx, &amp;order, id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := r.loadDelivery(ctx, &amp;order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := r.loadPayment(ctx, &amp;order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := r.loadItems(ctx, &amp;order); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;order, nil</span>
}

func (r *DBRepository) GetAll(ctx context.Context) ([]*model.Order, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx, `SELECT order_uid FROM orders`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get all orders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        orders := make([]*model.Order, 0, 256) // предвыделение

        for rows.Next() </span><span class="cov0" title="0">{
                var id string
                if err := rows.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Дальше тоже пробрасываем контекст
                <span class="cov0" title="0">order, err := r.GetByID(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}

//
// ---------------- PRIVATE (orders) ----------------
//

func (r *DBRepository) saveOrder(tx *sql.Tx, o *model.Order) error <span class="cov0" title="0">{
        _, err := tx.Exec(`
                INSERT INTO orders (
                        order_uid, track_number, entry, locale, internal_signature,
                        customer_id, delivery_service, shardkey, sm_id, date_created, oof_shard
                ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11)
                ON CONFLICT (order_uid) DO UPDATE SET
                        track_number = EXCLUDED.track_number,
                        entry = EXCLUDED.entry,
                        locale = EXCLUDED.locale,
                        internal_signature = EXCLUDED.internal_signature,
                        customer_id = EXCLUDED.customer_id,
                        delivery_service = EXCLUDED.delivery_service,
                        shardkey = EXCLUDED.shardkey,
                        sm_id = EXCLUDED.sm_id,
                        date_created = EXCLUDED.date_created,
                        oof_shard = EXCLUDED.oof_shard
        `, o.OrderUID, o.TrackNumber, o.Entry, o.Locale, o.InternalSignature,
                o.CustomerID, o.DeliveryService, o.Shardkey, o.SmID, o.DateCreated, o.OofShard)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("saveOrder: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *DBRepository) loadOrder(ctx context.Context, o *model.Order, id string) error <span class="cov0" title="0">{
        return r.db.QueryRowContext(ctx, `
                SELECT order_uid, track_number, entry, locale, internal_signature,
                       customer_id, delivery_service, shardkey, sm_id, date_created, oof_shard
                FROM orders WHERE order_uid = $1
        `, id).Scan(&amp;o.OrderUID, &amp;o.TrackNumber, &amp;o.Entry, &amp;o.Locale,
                &amp;o.InternalSignature, &amp;o.CustomerID, &amp;o.DeliveryService,
                &amp;o.Shardkey, &amp;o.SmID, &amp;o.DateCreated, &amp;o.OofShard)
}</span>

//
// ---------------- PRIVATE (delivery) ----------------
//

func (r *DBRepository) saveDelivery(tx *sql.Tx, o *model.Order) error <span class="cov0" title="0">{
        _, err := tx.Exec(`
                INSERT INTO deliveries (order_uid, name, phone, zip, city, address, region, email)
                VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
                ON CONFLICT ON CONSTRAINT deliveries_order_uid_uniq DO UPDATE SET
                        name = EXCLUDED.name,
                        phone = EXCLUDED.phone,
                        zip = EXCLUDED.zip,
                        city = EXCLUDED.city,
                        address = EXCLUDED.address,
                        region = EXCLUDED.region,
                        email = EXCLUDED.email
        `, o.OrderUID, o.Delivery.Name, o.Delivery.Phone, o.Delivery.Zip,
                o.Delivery.City, o.Delivery.Address, o.Delivery.Region, o.Delivery.Email)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("saveDelivery: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *DBRepository) loadDelivery(ctx context.Context, o *model.Order) error <span class="cov0" title="0">{
        return r.db.QueryRowContext(ctx, `
                SELECT delivery_id, order_uid, name, phone, zip, city, address, region, email
                FROM deliveries WHERE order_uid = $1
        `, o.OrderUID).Scan(&amp;o.Delivery.DeliveryID, &amp;o.Delivery.OrderUID, &amp;o.Delivery.Name,
                &amp;o.Delivery.Phone, &amp;o.Delivery.Zip, &amp;o.Delivery.City, &amp;o.Delivery.Address,
                &amp;o.Delivery.Region, &amp;o.Delivery.Email)
}</span>

//
// ---------------- PRIVATE (payment) ----------------
//

func (r *DBRepository) savePayment(tx *sql.Tx, o *model.Order) error <span class="cov0" title="0">{
        _, err := tx.Exec(`
                INSERT INTO payments (order_uid, transaction, request_id, currency, provider,
                        amount, payment_dt, bank, delivery_cost, goods_total, custom_fee)
                VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11)
                ON CONFLICT (order_uid) DO UPDATE SET
                        transaction = EXCLUDED.transaction,
                        request_id = EXCLUDED.request_id,
                        currency = EXCLUDED.currency,
                        provider = EXCLUDED.provider,
                        amount = EXCLUDED.amount,
                        payment_dt = EXCLUDED.payment_dt,
                        bank = EXCLUDED.bank,
                        delivery_cost = EXCLUDED.delivery_cost,
                        goods_total = EXCLUDED.goods_total,
                        custom_fee = EXCLUDED.custom_fee
        `, o.OrderUID, o.Payment.Transaction, o.Payment.RequestID, o.Payment.Currency,
                o.Payment.Provider, o.Payment.Amount, o.Payment.PaymentDt, o.Payment.Bank,
                o.Payment.DeliveryCost, o.Payment.GoodsTotal, o.Payment.CustomFee)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("savePayment: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *DBRepository) loadPayment(ctx context.Context, o *model.Order) error <span class="cov0" title="0">{
        return r.db.QueryRowContext(ctx, `
                SELECT payment_id, order_uid, transaction, request_id, currency, provider,
                       amount, payment_dt, bank, delivery_cost, goods_total, custom_fee
                FROM payments WHERE order_uid = $1
        `, o.OrderUID).Scan(&amp;o.Payment.PaymentID, &amp;o.Payment.OrderUID, &amp;o.Payment.Transaction,
                &amp;o.Payment.RequestID, &amp;o.Payment.Currency, &amp;o.Payment.Provider,
                &amp;o.Payment.Amount, &amp;o.Payment.PaymentDt, &amp;o.Payment.Bank,
                &amp;o.Payment.DeliveryCost, &amp;o.Payment.GoodsTotal, &amp;o.Payment.CustomFee)
}</span>

//
// ---------------- PRIVATE (items) ----------------
//

func (r *DBRepository) saveItems(tx *sql.Tx, o *model.Order) error <span class="cov0" title="0">{
        _, err := tx.Exec(`DELETE FROM items WHERE order_uid = $1`, o.OrderUID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("deleteItems: %w", err)
        }</span>

        <span class="cov0" title="0">for _, it := range o.Items </span><span class="cov0" title="0">{
                _, err = tx.Exec(`
                        INSERT INTO items (order_uid, chrt_id, track_number, price, rid, name,
                                sale, size, total_price, nm_id, brand, status)
                        VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)
                `, o.OrderUID, it.ChrtID, it.TrackNumber, it.Price, it.Rid, it.Name,
                        it.Sale, it.Size, it.TotalPrice, it.NmID, it.Brand, it.Status)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("insertItem: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *DBRepository) loadItems(ctx context.Context, o *model.Order) error <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx, `
                SELECT item_id, order_uid, chrt_id, track_number, price, rid, name,
                       sale, size, total_price, nm_id, brand, status
                FROM items WHERE order_uid = $1
        `, o.OrderUID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("loadItems: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var it model.Item
                if err := rows.Scan(&amp;it.ItemID, &amp;it.OrderUID, &amp;it.ChrtID, &amp;it.TrackNumber, &amp;it.Price,
                        &amp;it.Rid, &amp;it.Name, &amp;it.Sale, &amp;it.Size, &amp;it.TotalPrice, &amp;it.NmID, &amp;it.Brand, &amp;it.Status); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("scanItem: %w", err)
                }</span>
                <span class="cov0" title="0">o.Items = append(o.Items, it)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
